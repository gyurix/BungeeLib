package gyurix.bungeelib.api;

import gyurix.bungeelib.utils.BU;
import gyurix.bungeelib.utils.StringUtils;
import net.md_5.bungee.api.connection.ProxiedPlayer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import static gyurix.bungeelib.utils.BU.bl;

/**
 * VariableAPI - Used for advanced placeholder filling in Strings
 */
public class VariableAPI {
    /**
     * Empty list, used for quickly being passed to VariableHandlers if the placeholder does not have parameters
     */
    private static final ArrayList<Object> emptyList = new ArrayList<>();
    /**
     * List of placeholders, which were used in messages, and their handler throwed an error.
     * Since this is a high frequently used API, this field is required to only show an error once
     * instead of spamming the console with it.
     */
    private static final HashSet<String> errorVars = new HashSet<>();
    /**
     * Available VariableHandlers
     */
    private static final HashMap<String, VariableHandler> handlers = new HashMap();
    /**
     * List of placeholders, which were used in messages, but does not have a handler
     * Since this is a high frequently used API, this field is required to only show a missing
     * handler warning once instead of spamming the console with it.
     */
    private static final HashSet<String> missingHandlers = new HashSet<>();

    /**
     * Fills variables in the given message from the given character <b>recursively</b>.
     *
     * @param msg     - The message containing placeholders
     * @param from    - Index of character from which the variables should be filled
     * @param plr     - The Player whose data should be used in the message filling
     * @param extArgs - External object arguments
     * @return The first element is always the position of the last read character, the rest are
     * the objects generated by the VariableHandlers for the placeholders found in the message
     */
    public static ArrayList<Object> fill(String msg, int from, ProxiedPlayer plr, Object[] extArgs) {
        int msgLength = msg.length();
        int placeholderStart = from;
        ArrayList<Object> out = new ArrayList<>();

        /*  Loop through every character of the message from the given one
            until reaching the end of the message */
        for (int charId = from; charId < msgLength; ++charId) {
            char curChar = msg.charAt(charId);
            switch (curChar) {
                //Check if we found a placeholder beginning
                case '<': {
                    /* Add the substring of the input message from the last ended placeholder
                     *  until the current position for making sure that we don't lose that information.
                     *  If we don't have any characters between these two positions, then we are
                     *  not adding an empty string to the output for boosting client softwares performance
                     */
                    if (placeholderStart < charId)
                        out.add(msg.substring(placeholderStart, charId));

                    //Call this fill method recursively to find inner placeholders of this placeholder
                    ArrayList<Object> d = fill(msg, charId + 1, plr, extArgs);

                    //Skip checking characters already checked by calling the fill method recursively
                    charId = (Integer) d.get(0);
                    placeholderStart = charId + 1;

                    //Remove the current position data from the recursive calls output
                    d.remove(0);

                    //Fill the found placeholders using VariableHandlers and add them to the output
                    out.add(fillVar(plr, d, extArgs));
                    continue;
                }

                //Check if we found a placeholder ending
                case '>': {
                    //Add the placeholders text to the output
                    if (placeholderStart < charId)
                        out.add(msg.substring(placeholderStart, charId));

                    //Make sure the first element of the output will be the position of the last read character
                    out.add(0, charId);
                    return out;
                }
            }
        }
        //Add remaining text to the output
        if (placeholderStart < msg.length())
            out.add(msg.substring(placeholderStart, msg.length()));

        //Make sure the first element of the output will be the index of the last character of the message
        out.add(0, msg.length() - 1);
        return out;
    }

    /**
     * Fills variables in the given list of objects.
     *
     * @param plr     - The player whose data should be used in the variable filling
     * @param inside  - List of objects were the variables should be filled
     * @param extArgs - External arguments for the VariableHandler
     * @return The variable filled object
     */
    private static Object fillVar(ProxiedPlayer plr, List<Object> inside, Object[] extArgs) {
        //StringBuilder for calculating the placeholders full name
        StringBuilder nameBuilder = new StringBuilder();
        int listSize = inside.size();

        //Loop through the whole list of objects
        for (int readPos = 0; readPos < listSize; ++readPos) {
            String placeholder = String.valueOf(inside.get(readPos));
            int nameParamsSep = placeholder.indexOf(':');

            //Check if we found a parameterized placeholder in the readingPosition
            if (nameParamsSep != -1) {

                //Split it to placeholder name and placeholder parameters
                nameBuilder.append(placeholder.substring(0, nameParamsSep));
                ArrayList<Object> parameters = new ArrayList<>(inside.subList(readPos + 1, listSize));
                parameters.add(0, placeholder.substring(nameParamsSep + 1));

                //Calculate the value of the placeholder
                return handle(nameBuilder.toString(), plr, parameters, extArgs);
            }
            //If not, then then our placeholders name will be longer
            nameBuilder.append(placeholder);
        }

        //If our placeholder was not a parametered one, calculate it's value without using parameters
        return handle(nameBuilder.toString(), plr, emptyList, extArgs);
    }

    /**
     * Fills all the placeholders in the given message
     *
     * @param msg     - The variable fillable message
     * @param plr     - Player whose data should be used for variable filling
     * @param extArgs - External arguments passed to the VariableHandlers
     * @return The variable filled message
     */
    public static String fillVariables(String msg, ProxiedPlayer plr, Object... extArgs) {
        ArrayList<Object> out = fill(msg.replace("\\<", "\u0000").replace("\\>", "\u0001"), 0, plr, extArgs);
        out.remove(0);
        return StringUtils.join(out, "").replace('\u0000', '<').replace('\u0001', '>');
    }

    /**
     * Calculates the value of one placeholder using it's VariableHandler
     *
     * @param var     - The calculateable variable
     * @param plr     - The player whose data should be used for the calculation
     * @param inside  - Parameters of the placeholder
     * @param extArgs - External arguments, which should be passed to VariableHandler
     * @return The variable filling result
     */
    private static Object handle(String var, ProxiedPlayer plr, ArrayList<Object> inside, Object[] extArgs) {
        VariableHandler vh = handlers.get(var);
        //Check and report missing handlers only once during the execution of the whole software
        if (vh == null) {
            if (missingHandlers.add(var))
                BU.log(bl, "§cMissing handler for variable §f" + var + "§c!");
            return "<" + var + ">";
        }

        //Check and report error throwing handlers only once during the execution of the whole software
        try {
            return vh.getValue(plr, inside, extArgs);
        } catch (Throwable e) {
            if (errorVars.add(var)) {
                BU.log(bl, "§cError on calculating variable §f" + var + "§c!");
                BU.error(BU.cs, e, "SpigotLib", "gyurix");
            }
            return '<' + var + '>';
        }
    }

    /**
     * Registers the given handler for the given variables
     *
     * @param handler   - The registerable handler
     * @param variables - Variables to which the given handler should be registered
     */
    public static void registerHandler(VariableHandler handler, String... variables) {
        for (String v : variables)
            handlers.put(v, handler);
    }

    public static void unregisterHandler(String... variables) {
        for (String v : variables)
            handlers.remove(v);
    }

    /**
     * Custom VariableHandlers should implement this interface and add themselves to the handlers map, for
     * being used during the variable filling process
     */
    public interface VariableHandler {
        /**
         * Method for processing variable filling requests
         *
         * @param plr   - The player which data should be used for the filling
         * @param args  - Arguments being inside the placeholder
         * @param eArgs - External arguments
         * @return The proper replacement of the fillable placeholder
         */
        Object getValue(ProxiedPlayer plr, ArrayList<Object> args, Object[] eArgs);
    }

}

